## Melody 解题报告

### 算法原理

KMP 算法中的 `next[i]` 表示 $a[1\dots i]$ 的最长相等的真前缀和真后缀的长度。`next` 数组即为 KMP 自动机上匹配失败时的转移边，这些边构成了一棵树 $T$，题目中的每次查询对应在 $T$ 上求很多个结点的最近公共祖先（LCA）。

但由于题目要求 $x_i$ 长度非负，所以每次查询 $d_i$ 和 $d_j$ 时，不能直接求 $\text{LCA}(i, j)$，而是要分别求出 $i, j$ 最长相等的 **不重叠的** 真前缀和真后缀的长度。

### 细节处理

#### 如何求最长不重叠的长度？

通过 KMP 算法能够在线性的时间复杂度内求出 `next` 数组。我们再通过 `next` 数组求出 `jump` 数组——`jump[i]` 表示 $a[1\dots i]$ 的最长相等的 **不重叠的** 真前缀和真后缀的长度。

`next` 数组满足 $\text{next}[i] \le i - 1$，而 `jump` 数组满足 $\text{jump}[i] \le \left\lfloor\dfrac{i}{2}\right\rfloor$。因此，在转移时额外迭代 $k$ 使得 $k * 2 \le i$ 即可。

```cpp
// 求 a[l...r] 内的 jump 数组 g[]
void getJump(int l, int r) {
    for (int i = l, k = g[l - 1]; i <= r; ++i) {
        while (k > 0 && a[k + 1] != a[i])
            k = f[k][0];
       	if (a[k + 1] == a[i])
            ++k;
        // 一定要找到 *不重叠的* 前后缀，所以应当由 k * 2 <= i
        while (k * 2 > i)
            k = f[k][0];
        // k 即为满足要求的最长相等的 *不重叠的* 真前缀和真后缀的长度
        g[i] = k;
    }
}
```

值得注意的是，我们可以 **增量式地** 维护 `f` 和 `g`，从而不必在每次往字符串末尾添加字符时重新求一遍原来已经求过的 `f` 和 `g`。

#### 如何求 LCA？

预处理出 $i$ 在树上的 $2^j$ 级祖先，递推式为 $f(i, j) = f(f(i, j - 1), j - 1)$，边界条件为 $f(i, 0) = \text{next}[i]$。

倍增求 $\text{LCA}(u, v)$ 的过程实际上是试探的过程。如果 $u, v$ 的深度不同（不妨设 $u$ 比 $v$ 深），那么就先将 $u$ 调整至和 $v$ 同一高度，然后按 $2^j$ 的步长枚举 $f(u, j)$ 是否和 $f(v, j)$ 相同。不断调整直至二者满足 $f(u, 0) = f(v, 0)$，此时 $f(u, 0)$ 即为二者的最近公共祖先。

```cpp
// 求 u 和 v 的最近公共祖先，使用倍增算法
int lca(int u, int v) {
    // 不妨设 dep[u] > dep[v]
    if(dep[u] <= dep[v])
    std::swap(u, v);
    int del = dep[u] - dep[v];
    // 先将 u 和 v 调整至同一高度
    for (int i = 0; i <= lg2[dep[u]]; ++i)
        if (del & (1 << i))
            u = f[u][i];
    if (u == v)
        return u;
    // 再反复试探直至二者满足 f[u][0] == f[v][0]
    for (int i = lg2[dep[v]]; i >= 0; --i)
        if (f[u][i] != f[v][i]) {
            u = f[u][i];
            v = f[v][i];
        }
    return f[u][0];
}
```

### 时空复杂度分析

#### 时间复杂度

使用 KMP 算法求出 `next` 数组（即为 `f[][0]`）的时间复杂度为 $O(n)$，预处理倍增数组所需要的时间复杂度为 $O(n \log n)$。

对于第 $i$ 次操作：

- 如果是连接，则继续维护倍增数组所需时间复杂度为 $O(q_i\log q_i)$；

- 如果是查询，则倍增求 LCA 所需时间复杂度为 $O(\log n)$。

综上所述，整体的时间复杂度为 $O((n + m)\log n + q\log q)$。

#### 空间复杂度

`g` 数组长度为 $O(n)$，而求 LCA 的算法中倍增数组 `f` 所占的空间为 $O(n \log n)$，其余辅助数组所占空间也均为 $O(n)$。故总空间复杂度为 $O(n \log n)$。