## Build 解题报告

### 算法原理

对于每个结点 $u$，我们维护：
- 上一个兄弟结点的编号 `prev[u]`，如果没有上一个兄弟则为 $0$。
- 下一个兄弟结点的编号 `next_u`，如果没有下一个兄弟则为 $0$。
- 以 $u$ 为根的子树大小 `treeSize[u]`。
- $u$ 的“最左边的儿子” `ch[u][0]`，如果 $u$ 没有儿子则为 $0$。
- $u$ 的“最右边的儿子” `ch[u][1]`，如果 $u$ 没有儿子则为 $0$。
- $u$ 的子结点个数 `chSize[u]`。
- $u$ 的父结点 `fa[u]`。
- $u$ 及之后的兄弟结点中的高度最大值 `maxSuffix[u]`。

本质上，我们对于每一个结点都构造了一个 **双向链表**。

通过题目所给的子结点链表，我们能够构造出这棵树，并且以递归的形式初始化所有的 `treeSize[u]`。在遍历完 $u$ 的所有子结点之后，可以反向从“最右边的儿子”向“最左边的儿子”更新 `maxSuffix[u]`。

对于每次查询 $u$ 的高度，如果 $u$ 是叶子，则输出 $0$；否则输出 $u$ 的“最左边的儿子” $v$ 的 `1 + maxSuffix[v]`。

### 细节处理

#### 插入结点

插入结点时有两种边界情况：该位置是第 $0$ 个位置，或是第 $L$ 个位置。尤其是第 $L$ 个位置，由于此时子结点最大序号仅为 $L-1$，所以如果处理不当会导致链表结构紊乱。

#### 删除结点

需要特殊判断该结点是不是唯一的儿子。否则会导致 `ch[u][0]` 和 `ch[u][1]` 的前后结点所维护的信息被修改。由于此时 `ch[u][0]` 和 `ch[u][1]` 均为 $0$，即为 $1$ 的父结点，所以它并不应该被修改。

#### 为何维护 `maxSuffix`

如果改为对每个结点直接维护它的高度 $h$，那么删除操作的时候，并不能以 $O(cost)$ 的时间复杂度来维护它。对于被删除的 $u$ 的每一个祖先结点而言，它都无法得知自己的高度是否发生了变化，所以需要以 $O(n)$ 的代价来维护。

#### 其它细节

其余细节包括：
- 对 $1$ 结点（树根）设置虚拟的父结点 $0$，方便根结点相关信息的维护。
- 操作顺序应该是 **先删除再寻找插入的位置**，删除后树的结构已被更新，否则插入的位置会错位。

### 时空复杂度分析

#### 时间复杂度

- 删除操作

    对于删除操作，我们从该结点遍历到根结点并以每个结点 $O(1)$ 的代价维护路径上的 `treeSize` 和 `maxSuffix`，因此总代价为 $O(cost)$。

- 插入操作

    对于插入操作，我们从根结点遍历到目标结点，并以每个结点 $O(1)$ 的代价维护路径上的 `treeSize` 和 `maxSuffix`，因此总代价为 $O(cost)$。

- 查询操作

    由于对于每个结点都维护了子树大小，以及可以借助 `maxSuffix` 以 $O(1)$ 的代价求出结点高度，因此单次查询操作的代价为 $O(1)$。

综上所述，时间复杂度为 $O(n + m + cost)$。

#### 空间复杂度

由于只对每个结点维护了有穷个信息，所以空间复杂度为 $O(n)$。
